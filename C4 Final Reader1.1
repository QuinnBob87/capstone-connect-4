from re import X
import numpy as np
import random
import pygame
import sys
import math
import pandas as pd
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score, mean_squared_error
from sklearn.ensemble import RandomForestRegressor
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestClassifier
import joblib
from PIL import Image, ImageGrab, ImageDraw
import mouse


# Import pillow and mouse if you haven't already
# Go to https://papergames.io/en/connect4
# Start a game against the bot with unlimited time
# Starting player can be random
# When the countdown finishes, run the code and manually click back to the game window
# The extra time below is there so the board will be on screen when the game loop starts
# Then, the capstone AI should be able to play against the bot
# It takes a while to make a decision, so just be patient at the beginning especially
# When the game is over, go back to the code and hopefully the output should have the same board state
# Also, you can play against our AI by starting a game against a friend and scanning the QR code on your phone
# If you do that, and you go first, make sure you make a move before running the code, or it might not work
pygame.time.wait(5000)

# constants
ROW_COUNT = 6
COLUMN_COUNT = 7
PLAYER = 0
AI = 1
EMPTY = 0
PLAYER_PIECE = 1
AI_PIECE = 2
WINDOW_LENGTH = 4

# variables
game_turn = 0
WINDOW_LENGTH = 4
move_num = 1

# lists
columns = []
initial_colors = []

# data reader
df1 = pd.read_csv('data1.csv')
df2 = pd.read_csv('data2.csv')
df3 = pd.read_csv('data3.csv')
df4 = pd.read_csv('data4.csv')
df5 = pd.read_csv('data5.csv')
df6 = pd.read_csv('data6.csv')
df7 = pd.read_csv('data7.csv')
df8 = pd.read_csv('data8.csv')
df9 = pd.read_csv('data9.csv')
df10 = pd.read_csv('data10.csv')

# dataframe combiner
df = df1
df = df.append(df2)
df = df.append(df3)
df = df.append(df4)
df = df.append(df5)
df = df.append(df6)
df = df.append(df7)
df = df.append(df8)
df = df.append(df9)
df = df.append(df10)

# ML PORTION

# features for ml portion: board and turn
Features = df[['move', '(0,0)', '(0,1)', '(0,2)', '(0,3)', '(0,4)', '(0,5)', '(0,6)'
, '(1,0)', '(1,1)', '(1,2)', '(1,3)', '(1,4)', '(1,5)', '(1,6)'
, '(2,0)', '(2,1)', '(2,2)', '(2,3)', '(2,4)', '(2,5)', '(2,6)'
, '(3,0)', '(3,1)', '(3,2)', '(3,3)', '(3,4)', '(3,5)', '(3,6)'
, '(4,0)', '(4,1)', '(4,2)', '(4,3)', '(4,4)', '(4,5)', '(4,6)'
, '(5,0)', '(5,1)', '(5,2)', '(5,3)', '(5,4)', '(5,5)', '(5,6)']]

# targer for ml protion: score
Target = df['p1_score']

# train test split
X_train, X_test, y_train, y_test = train_test_split(Features, Target, test_size=.2)
# Decision Tree Regressor Code
tree = DecisionTreeRegressor()
tree.fit(X_train, y_train)
y_pred = tree.predict(X_test)

# Random Forrest Regresor Code(This is the one we use)
clf = RandomForestRegressor(n_estimators=100, random_state=42)
clf.fit(Features, Target)
y_pred = clf.predict(Features)

# linear regression moodel
reg = LinearRegression()
reg.fit(X_train, y_train)
y_pred2 = reg.predict(X_test)
r2 = r2_score(y_test, y_pred2)
mse = mean_squared_error(y_test, y_pred2)

# Functions

# Creates an empty board
def create_board():
    board = np.zeros((ROW_COUNT, COLUMN_COUNT))
    return board

# Drops a piece at a position for a given player
def drop_piece(board, row, col, piece):
  board[row][col] = piece
   
# Check if a piece can be placed in a certain location
def is_valid_location(board, col):
    return board[ROW_COUNT - 1][col] == 0

# Finds the next available row for new moves given a column
def get_next_open_row(board, col):
    for r in range(ROW_COUNT):
        if board[r][col] == 0:
            return r

# Prints the board when needed
def print_board(board):
    print(np.flip(board, 0))

# Check if the winning move has been made by either player
def winning_move(board, piece):
    # Check horizontal locations for win
    for c in range(COLUMN_COUNT - 3):
        for r in range(ROW_COUNT):
            if board[r][c] == piece and board[r][c + 1] == piece and board[r][c + 2] == piece and board[r][
                c + 3] == piece:
                return True

    # Check vertical locations for win
    for c in range(COLUMN_COUNT):
        for r in range(ROW_COUNT - 3):
            if board[r][c] == piece and board[r + 1][c] == piece and board[r + 2][c] == piece and board[r + 3][
                c] == piece:
                return True

    # Check positively sloped diaganols
    for c in range(COLUMN_COUNT - 3):
        for r in range(ROW_COUNT - 3):
            if board[r][c] == piece and board[r + 1][c + 1] == piece and board[r + 2][c + 2] == piece and board[r + 3][
                c + 3] == piece:
                return True

    # Check negatively sloped diaganols
    for c in range(COLUMN_COUNT - 3):
        for r in range(3, ROW_COUNT):
            if board[r][c] == piece and board[r - 1][c + 1] == piece and board[r - 2][c + 2] == piece and board[r - 3][
                c + 3] == piece:
                return True

# Determine scores based on where pieces have been placed
def evaluate_window(window, piece):
    score = 0
    opp_piece = PLAYER_PIECE
    if piece == PLAYER_PIECE:
        opp_piece = AI_PIECE
    # Award points for consecutive pieces
    if window.count(piece) == 4:
        score += 100
    elif window.count(piece) == 3 and window.count(EMPTY) == 1:
        score += 10
    elif window.count(piece) == 2 and window.count(EMPTY) == 2:
        score += 5

    # Subtract points for opponent getting consecutive pieces
    if window.count(opp_piece) == 4:
        score -= 1000
    elif window.count(opp_piece) == 3 and window.count(EMPTY) == 1:
        score -= 12
    elif window.count(opp_piece) == 2 and window.count(EMPTY) == 2:
        score -= 1

    return score

# Award extra points based on column placement.
# This one is a combination of basic strategy and our Linear Regression Model
def score_position2(board, piece):
    score = 0

    ## Score columns
    # 1 and 7 (edges)
    column1 = [int(i) for i in list(board[:, 0])]
    column7 = [int(i) for i in list(board[:, 6])]
    column1count = column1.count(piece)
    column7count = column7.count(piece)
    score += column1count * 0
    score += column7count * 0

    # 2 and 6
    column2 = [int(i) for i in list(board[:, 1])]
    column6 = [int(i) for i in list(board[:, 5])]
    column2count = column2.count(piece)
    column6count = column6.count(piece)
    score += column2count * 1
    score += column6count * 1

    # 3 and 5
    column3 = [int(i) for i in list(board[:, 2])]
    column5 = [int(i) for i in list(board[:, 4])]
    column3count = column3.count(piece)
    column5count = column5.count(piece)
    score += column3count * 2
    score += column5count * 2

    # 4 (center)
    column4 = [int(i) for i in list(board[:, 3])]
    column4count = column4.count(piece)
    score += column4count * 3


    ## Score Horizontal
    for r in range(ROW_COUNT):
        row_array = [int(i) for i in list(board[r, :])]
        for c in range(COLUMN_COUNT - 3):
            window = row_array[c:c + WINDOW_LENGTH]
            score += evaluate_window(window, piece)

    ## Score Vertical
    for c in range(COLUMN_COUNT):
        col_array = [int(i) for i in list(board[:, c])]
        for r in range(ROW_COUNT - 3):
            window = col_array[r:r + WINDOW_LENGTH]
            score += evaluate_window(window, piece)

    ## Score posiive sloped diagonal
    for r in range(ROW_COUNT - 3):
        for c in range(COLUMN_COUNT - 3):
            window = [board[r + i][c + i] for i in range(WINDOW_LENGTH)]
            score += (evaluate_window(window, piece) * 1.25)

    ## Score negative sloped diagonal
    for r in range(ROW_COUNT - 3):
        for c in range(COLUMN_COUNT - 3):
            window = [board[r + 3 - i][c + i] for i in range(WINDOW_LENGTH)]
            score += (evaluate_window(window, piece) * 1.25)
    # assigns the basic strategy to traditional score
    trad_score = score

# ml lin reg score
    ml_code = reg.intercept_ + reg.coef_[0] * game_turn
    if board[0][0] == piece:
      ml_code += reg.coef_[1]
    if board[0][1] == piece:
      ml_code += reg.coef_[2]
    if board[0][2] == piece:
      ml_code += reg.coef_[3]
    if board[0][3] == piece:
      ml_code += reg.coef_[4]
    if board[0][4] == piece:
      ml_code += reg.coef_[5]
    if board[0][5] == piece:
      ml_code += reg.coef_[6]
    if board[0][6] == piece:
      ml_code += reg.coef_[7]
    if board[1][0] == piece:
      ml_code += reg.coef_[8]
    if board[1][1] == piece:
      ml_code += reg.coef_[9]
    if board[1][2] == piece:
      ml_code += reg.coef_[10]
    if board[1][3] == piece:
      ml_code += reg.coef_[11]
    if board[1][4] == piece:
      ml_code += reg.coef_[12]
    if board[1][5] == piece:
      ml_code += reg.coef_[13]
    if board[1][6] == piece:
      ml_code += reg.coef_[14]
    if board[2][0] == piece:
      ml_code += reg.coef_[15]
    if board[2][1] == piece:
      ml_code += reg.coef_[16]
    if board[2][2] == piece:
      ml_code += reg.coef_[17]
    if board[2][3] == piece:
      ml_code += reg.coef_[18]
    if board[2][4] == piece:
      ml_code += reg.coef_[19]
    if board[2][5] == piece:
      ml_code += reg.coef_[20]
    if board[2][6] == piece:
      ml_code += reg.coef_[21]
    if board[3][0] == piece:
      ml_code += reg.coef_[22]
    if board[3][1] == piece:
      ml_code += reg.coef_[23]
    if board[3][2] == piece:
      ml_code += reg.coef_[24]
    if board[3][3] == piece:
      ml_code += reg.coef_[25]
    if board[3][4] == piece:
      ml_code += reg.coef_[26]
    if board[3][5] == piece:
      ml_code += reg.coef_[27]
    if board[3][6] == piece:
      ml_code += reg.coef_[28]
    if board[4][0] == piece:
      ml_code += reg.coef_[29]
    if board[4][1] == piece:
      ml_code += reg.coef_[30]
    if board[4][2] == piece:
      ml_code += reg.coef_[31]
    if board[4][3] == piece:
      ml_code += reg.coef_[32]
    if board[4][4] == piece:
      ml_code += reg.coef_[33]
    if board[4][5] == piece:
      ml_code += reg.coef_[34]
    if board[4][6] == piece:
      ml_code += reg.coef_[35]
    if board[5][0] == piece:
      ml_code += reg.coef_[36]
    if board[5][1] == piece:
      ml_code += reg.coef_[37]
    if board[5][2] == piece:
      ml_code += reg.coef_[38]
    if board[5][3] == piece:
      ml_code += reg.coef_[39]
    if board[5][4] == piece:
      ml_code += reg.coef_[40]
    if board[5][5] == piece:
      ml_code += reg.coef_[41]
    if board[5][6] == piece:
      ml_code += reg.coef_[42]

    # ml code can generate large numbers, this codes evens it out
    if ml_code > trad_score:
      if trad_score > 0:
        if ml_code/trad_score > 2:
          trad_score = ((ml_code/trad_score)/2) * trad_score

    score = trad_score + ml_code
    

    return score

# This is the score that utilizes the Random Forrest Regressor Model
def score_position(board, piece):
  colsss = []
  colsss.append('move')
  # Our prevous game data is stored in a dataframe format.
  # Our Current game data is stored in a 2-d list format.
  # The code below Converts the current game from a 2-d list to a dataframe
  for y in range(6):
          for z in range(7):
              colsss.append('(' + str(y) + ',' + str(z) + ')')
  de_board = pd.DataFrame(columns= colsss)
  # assiging the column titles
  de_board.at[0, 'move'] = game_turn
  for y in range(6):
            for z in range(7):
                de_board.at[0, '(' + str(y) + ',' + str(z) + ')'] = board[y][z]
  prediction = clf.predict(de_board)
  # return the predicted score of a given board state
  return prediction


def get_valid_locations(board):
    valid_locations = []
    for col in range(COLUMN_COUNT):
        if is_valid_location(board, col):
            valid_locations.append(col)
    return valid_locations

# Find valid locations for the next move to be placed
def pick_best_move(board, piece):
    valid_locations = get_valid_locations(board)
    # sets scores to an unobtainable value
    best_score = -10000
    tmpbest_score = 10000000
    highest= -100000000
    # list for scores
    scores1=[]
    # list for column numbers
    poss = []
    for col in valid_locations:
        # sets oppiece to the opponents corresponding piece number
        if piece == 1:
          oppiece = 2
        elif piece == 2:
          oppiece = 1

        #player move #1
        # gets the next spot to place piece
        row = get_next_open_row(board, col)
        #Creates a temporary board
        temp_board = board.copy()
        # drops hypothetical piece # 1
        drop_piece(temp_board, row, col, piece)

        # opponent move
        # gets possible moves after player's first move
        valid_locations2 = get_valid_locations(temp_board)
        scores2 = [] 
        for col2 in valid_locations2:
          # gets the next spot to place piece
          row2 = get_next_open_row(temp_board, col2)
          #Creates a temporary board
          temp_board2 = temp_board.copy()
          # drops hypothetical piece # 2
          drop_piece(temp_board2, row, col2, oppiece)

          #player move #2
          valid_locations3 = get_valid_locations(temp_board2)
          scores3 = []
          for col3 in valid_locations2:
            # gets the next spot to place piece
            row3 = get_next_open_row(temp_board2, col3)
            #Creates a temporary board
            temp_board3 = temp_board2.copy()
            # drops hypothetical piece # 3
            drop_piece(temp_board3, row, col3, piece)
            # assigns the score to this possibility
            score = score_position(temp_board3, piece)
            #gets list of the best moves of 2nd player move
            scores3.append(score)
          #gets best move of 2nd player move
          scores2.append(max(scores3))
        #gets best move after the opponent plays their best move
        scores1.append(min(scores2))
        # assigns the position of the moves
        poss.append(col)

    #looks through the list of the best moves
    for x in range(len(scores1)):
        # finds the highest score of the list
        if scores1[x] > highest:
            highest = scores1[x]
            # sets the column based off the position of scores in score list
            index = x
    best_col = poss[index]
    # returns the location of the best move
    return best_col

def position2click(col):
    mouse_x = 660 + (col * 100)

    mouse.move(mouse_x, 835)
    pygame.time.wait(100)
    mouse.click()


def find_opponent_move(im1):
    move_made = False
    valid_locations = get_valid_locations(board)
    while not move_made:
        pygame.time.wait(1000)
        im2 = ImageGrab.grab()
        for col in valid_locations:
            row = get_next_open_row(board, col)
            screen_pos = (640+(col*100), 800-(row*100))

            rgb1 = im1.getpixel(screen_pos)
            rgb2 = im2.getpixel(screen_pos)

            if rgb1 != rgb2 or rgb1 != (16, 27, 39):
                drop_piece(board, row, col, AI_PIECE)
                move_made = True

# Setting Up Game

board = create_board()
game_over = False

turn_image = ImageGrab.grab()
for col in range(COLUMN_COUNT):
    screen_color = turn_image.getpixel((640+(col*100), 800))
    initial_colors.append(screen_color)

turn = PLAYER

for c in initial_colors:
    if c != (16, 27, 39):
        turn = AI
        image1 = ImageGrab.grab()

while not game_over:
  # player 1 turn
  if turn == PLAYER:
    col = pick_best_move(board, PLAYER_PIECE)
    row = get_next_open_row(board, col)
    image1 = ImageGrab.grab()
    pygame.time.wait(100)
    drop_piece(board, row, col, PLAYER_PIECE)
    position2click(col)
    if winning_move(board, PLAYER_PIECE):
      game_over = True
      print_board(board)

  # Ask for Player 2 turn
  if turn == AI and not game_over:
    pygame.time.wait(1000)
    find_opponent_move(image1)
    pygame.time.wait(500)
    if winning_move(board, AI_PIECE):
      game_over = True
      print_board(board)
